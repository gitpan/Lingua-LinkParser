.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH LinkParser 3 "perl 5.005, patch 03" "8/Feb/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Lingua::LinkParser \- Perl module implementing the Link Grammar Parser by Sleator, Temperley and Lafferty at CMU.
.SH "SYNOPSIS"
.PP
.Vb 8
\&  use Lingua::LinkParser;
\& 
\&  my $parser = new Lingua::LinkParser;
\&  my $sentence = $parser->parse_sentence("This is the turning point.");
\&  my @linkages = $parser->get_linkages($sentence);
\&  foreach $linkage (@linkages) {
\&      print ($parser->get_diagram($linkage));
\&  }
.Ve
.SH "DESCRIPTION"
To quote the Link Grammar documentation, \*(L"the Link Grammar Parser is a syntactic parser of English, based on link grammar, an original theory of English syntax. Given a sentence, the system assigns to it a syntactic structure, which consists of set of labeled links connecting pairs of words.\*(R"
.PP
This module provides acccess to the parser API using Perl objects to easily analyze linkages. The module organizes data returned from the parser API into an object hierarchy consisting of, in order, sentence, linkage, sublinkage, and link. If this is unclear to you, see the several examples in the \*(L'eg/\*(R' directory for a jumpstart on using these objects.
.PP
The objects within this module should not be confused with the types familiar to users of the Link Parser API. The objects used in this module reorganize the API data in a way more usable and friendly to Perl users, and do not exactly represent the types used in the API.
.PP
This documentation must be supplemented with the extensive texts included with the Link Parser and on the Link Parser web site.
.Ip "$parser = new Lingua::LinkParser(\s-1DICT_PATH\s0,\s-1KNOWLEDGE_PATH\s0)" 5
This returns a new Lingua::LinkParser object, loads the specified dictionary
files, and sets basic configuration. If no dictionary files are specified, the
parser will attempt to open the default files specified in the header files.
.Ip "$parser->opts(\s-1OPTION_NAME\s0,\s-1OPTION_VALUE\s0)" 5
This sets the parser option \s-1OPTION_NAME\s0 to the value specified by \s-1OPTION_VALUE\s0.
A full list of these options is found at the end of this document, as well as
in the Link Parser distribution documentation.
.Ip "$sentence = $parser->create_sentence(\s-1TEXT\s0)" 5
Creates and assigns a sentence object (Lingua::LinkParser::Sentence) using the supplied value. This object is used in subsequent creation and analysis of linkages.
.Ip "$sentence->num_linkages" 5
Returns the number of linkages found for \f(CW$sentence\fR.
.Ip "$linkage = $sentence->linkage(\s-1NUM\s0)" 5
Assigns a linkage object (Lingua::LinkParser::Linkage) for linkage \s-1NUM\s0 of sentence \f(CW$sentence\fR.
.Ip "@linkages = $sentence->linkages" 5
Assigns a list of linkage objects for all linkages of \f(CW$sentence\fR.
.Ip "$linkage->num_sublinkages" 5
Returns the number of sublinkages for linkage \f(CW$linkage\fR.
.Ip "$sublinkage = $linkage->sublinkage(\s-1NUM\s0)" 5
Assigns a sublinkage object (Lingua::LinkParser::Linkage::Sublinkage) for sublinkage \s-1NUM\s0 of linkage \f(CW$linkage\fR.
.Ip "@sublinkages = $linkage->sublinkages" 5
Assigns an array of sublinkage objects.
.Ip "$sublinkage->num_links" 5
Returns the number of links for sublinkage \f(CW$sublinkage\fR.
.Ip "$link = $sublinkage->link(\s-1NUM\s0)" 5
Assigns a link object (Lingua::LinkParser::Link) for link \s-1NUM\s0 of sublinkage
\f(CW$sublinkage\fR.
.Ip "@links = $sublinkage->links" 5
Assigns an array of link objects.
.Ip "$link->length" 5
Returns the number of words spanned by \f(CW$link\fR.
.Ip "$link->label" 5
Returns the \*(L"intersection\*(R" label for \f(CW$link\fR.
.Ip "$link->llabel" 5
Returns the left label for \f(CW$link\fR.
.Ip "$link->rlabel" 5
Returns the right label for \f(CW$link\fR.
.Ip "$link->lword" 5
Returns the number of the left word for \f(CW$link\fR.
.Ip "$link->rword" 5
Returns the number of the right word for \f(CW$link\fR.
.Ip "$parser->get_diagram($linkage)" 5
Returns an \s-1ASCII\s0 pretty-printed diagram of the specified linkage or sublinkage.
.Ip "$parser->get_postscript($linkage)" 5
Returns Postscript code for a diagram of the specified linkage or sublinkage.
.Ip "$parser->get_domains($linkage)" 5
Returns formatted \s-1ASCII\s0 text showing the links and domains for the specified linkage or sublinkage.
.SH "OTHER FUNCTIONS"
A few high-level functions have also been provided.
.Ip "@bigstruct = $sentence->get_bigstruct  " 5
Assigns a potentially large data structure merging all linkages/sublinkages/links for \f(CW$sentence\fR. This structure is an array of hashes, with a single array entry for each word in the sentence. This function is only useful for high-level analysis of sentence grammar; most applications should be served by using the below functions.
 
This array has the following structure:
.Sp
.Vb 7
\& @bigstruct ( %{ 'word'  => 'WORD',
\&                'links' => %{
\&                    'LINKTYPE_LINKAGENUM' => 'TARGETWORDNUM',...
\&                 },
\&                }, ...
\&             }
\&           , ...);
.Ve
Where \s-1LINKAGENUM\s0 is the number of the linkage for \f(CW$sentence\fR, and \s-1LINKTYPE\s0 is the link type label. \s-1TARGETWORDNUM\s0 is the number of the word to which each link connects.
 
\fIget_bigstruct()\fR can be useful in finding, for example, all links for a given word in a given sentence:
 
   \f(CW$sentence\fR = \f(CW$parser\fR\->\fIcreate_sentence\fR\|(
        \*(L"Architecture is present in nearly every civilized society.");
   \f(CW@bigstruct\fR = \f(CW$sentence\fR\->get_bigstruct;
   while (($k,$v) = each %{$bigstruct[6]\->{links}} )
        { print \*(L"$k => \*(L", \f(CW$bigstruct\fR[$v]\->{word}, \*(L"\en\*(R"; }
 
This would output:
 
    A => civilized.a
    Jp => in
    Dsu => every.d
 
Signifying that for word \*(L"society\*(R", links are found of type A (pre-noun adjective) with \*(L"civilized\*(R" (tagged \*(L'a\*(R' for adjective), type Jp (preposition to object) with \*(L"in\*(R", and type Dsu (noun determiner, singular-mass) with word \*(L"every\*(R", which is tagged \*(L'd\*(R' for determiner.
.SH "LINK PARSER OPTIONS"
The following list of options may be set or retrieved with Lingua::LinkParser object with the function:
.PP
.Vb 1
\&    $parser->opts(OPTION, [VALUE])
.Ve
Supplying no VALUE returns the current value for OPTION. Note that not all of the options are implemented by the API, and instead are intended for use by the program.
.PP
.Vb 2
\& verbosity
\&  The level of detail reported during processing, 0 reports nothing.
.Ve
.Vb 2
\& linkage_limit
\&  The maximum number of linkages to process for a sentence.
.Ve
.Vb 2
\& disjunct_cost
\&  Determines the maximum disjunct cost used during parsing, where the cost of a disjunct is equal to the maximum cost of all of its connectors.
.Ve
.Vb 3
\& min_null_count
\& max_null_count
\&  The range of null links to parse.
.Ve
.Vb 2
\& null_block
\&  Sets the block count ratio for null linkages; a value of '4' causes a linkage of 1, 2, 3, or 4 null links to have a null cost of 1.
.Ve
.Vb 2
\& short_length
\&  Limits the number length of links to this value (the number of words a link can span).
.Ve
.Vb 2
\& islands_ok
\&  Allows 'islands' of links (links not connected to the 'wall') when set.
.Ve
.Vb 2
\& max_parse_time
\&  Determines the approximate maximum time permitted for parsing.
.Ve
.Vb 2
\& max_memory
\&  Determines the maximum memory allowed during parsing.
.Ve
.Vb 5
\& timer_expired
\& memory_exhausted
\& resources_exhausted
\& reset_resources
\&  These options tell whether the timer or memory constraints have been exceeded during parsing.
.Ve
.Vb 1
\& cost_model_type
.Ve
.Vb 2
\& screen_width
\&  Sets the screen width for pretty-print functions.
.Ve
.Vb 2
\& allow_null
\&  Allow or disallow null links in linkages.
.Ve
.Vb 2
\& display_walls
\&  Toggles the display of linkage "walls".
.Ve
.Vb 2
\& all_short_connectors
\&  If true, then all connectors have length restrictions imposed on them.
.Ve
.SH "BUGS/TODO"
- I suspect the docs are lacking. This is a very-beta release. Please supply me with input as to the accuracy and any bugs or enhancements you may have.
.PP
- Add domain functions
.SH "AUTHOR"
Daniel Brian, dbrian@clockwork.net
.SH "SEE ALSO"
\fIperl\fR\|(1).
http://www.link.cs.cmu.edu/link/.

.rn }` ''
.IX Title "LinkParser 3"
.IX Name "Lingua::LinkParser - Perl module implementing the Link Grammar Parser by Sleator, Temperley and Lafferty at CMU."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "$parser = new Lingua::LinkParser(\s-1DICT_PATH\s0,\s-1KNOWLEDGE_PATH\s0)"

.IX Item "$parser->opts(\s-1OPTION_NAME\s0,\s-1OPTION_VALUE\s0)"

.IX Item "$sentence = $parser->create_sentence(\s-1TEXT\s0)"

.IX Item "$sentence->num_linkages"

.IX Item "$linkage = $sentence->linkage(\s-1NUM\s0)"

.IX Item "@linkages = $sentence->linkages"

.IX Item "$linkage->num_sublinkages"

.IX Item "$sublinkage = $linkage->sublinkage(\s-1NUM\s0)"

.IX Item "@sublinkages = $linkage->sublinkages"

.IX Item "$sublinkage->num_links"

.IX Item "$link = $sublinkage->link(\s-1NUM\s0)"

.IX Item "@links = $sublinkage->links"

.IX Item "$link->length"

.IX Item "$link->label"

.IX Item "$link->llabel"

.IX Item "$link->rlabel"

.IX Item "$link->lword"

.IX Item "$link->rword"

.IX Item "$parser->get_diagram($linkage)"

.IX Item "$parser->get_postscript($linkage)"

.IX Item "$parser->get_domains($linkage)"

.IX Header "OTHER FUNCTIONS"

.IX Item "@bigstruct = $sentence->get_bigstruct  "

.IX Header "LINK PARSER OPTIONS"

.IX Header "BUGS/TODO"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

